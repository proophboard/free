/**
 * Copyright (c) 2006-2015, JGraph Ltd
 */

function EventModelingSliceShapeXml ()
{
    return `<mxGraphModel dx="3168.85" dy="218.32" grid="1" gridSize="16" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="0" pageScale="1" pageWidth="827" pageHeight="1169" background="#ffffff">
  <root>
    <mxCell id="e975feae-1579-4c09-98d0-98cbf2108aec"/>
    <mxCell id="7fe80d19-d317-4e9d-8296-96c598786d78" parent="e975feae-1579-4c09-98d0-98cbf2108aec"/>
    <boundedContext label="" type="boundedContext" tags="pb:eventmodel" id="mA2vXdNWByc9MfDcyrG2Q5">
      <mxCell style="boundedContext;fillColor=none;rounded=1;arcSize=5;" vertex="1" parent="7fe80d19-d317-4e9d-8296-96c598786d78">
        <mxGeometry x="0" y="0" width="1360" height="1478" as="geometry"/>
      </mxCell>
    </boundedContext>
    <UserObject label="&amp;nbsp;" tags="pb:timehandle,pb:ethidden" id="dsVaY13V9UzHGpd8xMwqXc">
      <mxCell style="freeText;locked=1;resizable=0;rotatable=0" vertex="1" tempVisible="1" parent="mA2vXdNWByc9MfDcyrG2Q5">
        <mxGeometry x="1320" y="694" width="20" height="112" as="geometry"/>
      </mxCell>
    </UserObject>
    <icon label="" type="icon" tags="pb:connected,pb:lanehandle,pb:ethidden" id="dhic33kxZxP4LY5TWGgXoC">
      <mxCell style="icon;locked=1;resizable=0;rotatable=0;image=data:image/svg+xml,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; style=&quot;fill:#4D4D4D&quot; viewBox=&quot;0 0 512 512&quot;&gt;&lt;path d=&quot;M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm61.8-104.4l-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6 0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z&quot;/&gt;&lt;/svg&gt;;" vertex="1" tempVisible="1" parent="mA2vXdNWByc9MfDcyrG2Q5">
        <mxGeometry x="12.945945945945823" y="733.9459459459458" width="48" height="30" as="geometry"/>
      </mxCell>
    </icon>
    <UserObject label="&amp;nbsp;" tags="pb:lanehandle,pb:ethidden" id="bbQa81UnqVcdGoGDaAKFHg">
      <mxCell style="freeText;locked=1;resizable=0;rotatable=0" vertex="1" tempVisible="1" parent="mA2vXdNWByc9MfDcyrG2Q5">
        <mxGeometry x="13" y="1050" width="16" height="12" as="geometry"/>
      </mxCell>
    </UserObject>
    <UserObject label="&amp;nbsp;" tags="pb:lanehandle,pb:ethidden" id="3k5XYDYFCJ3N6UnnANo1JT">
      <mxCell style="freeText;locked=1;resizable=0;rotatable=0" vertex="1" tempVisible="1" parent="mA2vXdNWByc9MfDcyrG2Q5">
        <mxGeometry x="17" y="450" width="16" height="12" as="geometry"/>
      </mxCell>
    </UserObject>    
    <UserObject label="Role" tags="pb:connected,pb:lanehandle" id="4AvHEmpSe9RuusBSyVYQw">
      <mxCell style="freeText;fontSize=24;fontColor=#4d4d4d;fontStyle=1;align=left;" vertex="1" tempVisible="1" parent="mA2vXdNWByc9MfDcyrG2Q5">
        <mxGeometry x="10" y="250" width="150" height="100" as="geometry"/>
      </mxCell>
    </UserObject>
    <UserObject label="Module" tags="pb:connected,pb:lanehandle" id="cfy41E6BQWW9znDCZ7stoa">
      <mxCell style="freeText;fontSize=24;fontColor=#4d4d4d;fontStyle=1;align=left;" vertex="1" tempVisible="1" parent="mA2vXdNWByc9MfDcyrG2Q5">
        <mxGeometry x="10" y="850" width="150" height="100" as="geometry"/>
      </mxCell>
    </UserObject>
    <UserObject label="" tags="pb:connected,pb:lanehandle,pb:apilabel,pb:ethidden" id="ofT2q5tZpnnpBXYV2t82dN">
      <mxCell style="freeText;locked=1;resizable=0;rotatable=0;fillColor=transparent;" vertex="1" tempVisible="1" parent="mA2vXdNWByc9MfDcyrG2Q5">
        <mxGeometry x="9.959459459459367" y="556" width="1" height="100" as="geometry"/>
      </mxCell>
    </UserObject>
    <UserObject label="&amp;nbsp;" tags="pb:timehandle,pb:ethidden" id="7EpWcCuQxvTPAGXcuhT5Ns">
      <mxCell style="freeText;locked=1;resizable=0;rotatable=0" vertex="1" parent="mA2vXdNWByc9MfDcyrG2Q5">
        <mxGeometry x="1320" y="450" width="20" height="12" as="geometry"/>
      </mxCell>
    </UserObject>
    <UserObject label="&amp;nbsp;" tags="pb:timehandle,pb:ethidden" id="whrJtCGVkgnTFGHqf1J9ft">
      <mxCell style="freeText;locked=1;resizable=0;rotatable=0" vertex="1" parent="mA2vXdNWByc9MfDcyrG2Q5">
        <mxGeometry x="1320" y="1050" width="20" height="12" as="geometry"/>
      </mxCell>
    </UserObject>
    <UserObject label="" tags="pb:connected" id="fuqxbhtEwgcfbHXwLPdc2H">
      <mxCell style="html=1;strokeWidth=5;edgeStyle=isometricEdgeStyle" edge="1" tempVisible="1" parent="mA2vXdNWByc9MfDcyrG2Q5" source="dhic33kxZxP4LY5TWGgXoC" target="dsVaY13V9UzHGpd8xMwqXc">
        <mxGeometry relative="1" as="geometry"/>
      </mxCell>
    </UserObject>
    <mxCell id="6NY9Pv7fUMngaTc2kQoBDs" style="edgeStyle=isometricEdgeStyle;html=1;endArrow=none;strokeWidth=2;strokeColor=#bababa;" edge="1" tempVisible="1" parent="mA2vXdNWByc9MfDcyrG2Q5" source="bbQa81UnqVcdGoGDaAKFHg" target="whrJtCGVkgnTFGHqf1J9ft">
      <mxGeometry relative="1" as="geometry"/>
    </mxCell>
    <mxCell id="xmp8o2e4BFAD1wtg2dutV" style="edgeStyle=isometricEdgeStyle;html=1;endArrow=none;strokeWidth=2;strokeColor=#bababa;" edge="1" tempVisible="1" parent="mA2vXdNWByc9MfDcyrG2Q5" source="3k5XYDYFCJ3N6UnnANo1JT" target="7EpWcCuQxvTPAGXcuhT5Ns">
      <mxGeometry relative="1" as="geometry"/>
    </mxCell>    
  </root>
</mxGraphModel>`;
}

function IframeShape(bounds, src, fill, stroke, strokewidth)
{
    console.log("iframe shape construct");
    mxImageShape.call(this, bounds, src, fill, stroke, strokewidth);
    this.src = 'https://www.figma.com/embed?embed_host=share&url=https%3A%2F%2Fwww.figma.com%2Fproto%2FCtF7XyKa1LEGsFmYQUK4yn%2FInspectIO-UI%3Fnode-id%3D7%253A74'; //src;
}
mxUtils.extend(IframeShape, mxImageShape);

IframeShape.prototype.paintVertexShape = function(c, x, y, w, h)
{
    if (this.src != null)
    {
        console.log("paintVertexShape")
        var fill = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, null);
        var stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);

        if (fill != null)
        {
            // Stroke rendering required for shadow
            c.setFillColor(fill);
            c.setStrokeColor(stroke);
            c.rect(x, y, w, h);
            c.fillAndStroke();
        }

        // FlipH/V are implicit via mxShape.updateTransform
        c.iframe(x, y, w, h, this.src);

        var stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);

        if (stroke != null)
        {
            c.setShadow(false);
            c.setStrokeColor(stroke);
            c.rect(x, y, w, h);
            c.stroke();
        }
    }
    else
    {
        mxRectangleShape.prototype.paintBackground.apply(this, arguments);
    }
};

IframeShape.prototype.redrawHtmlShape = function()
{
    this.node.style.left = Math.round(this.bounds.x) + 'px';
    this.node.style.top = Math.round(this.bounds.y) + 'px';
    this.node.style.width = Math.max(0, Math.round(this.bounds.width)) + 'px';
    this.node.style.height = Math.max(0, Math.round(this.bounds.height)) + 'px';
    this.node.innerHTML = '';

    if (this.src != null)
    {
        var fill = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, '');
        var stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, '');
        this.node.style.backgroundColor = fill;
        this.node.style.borderColor = stroke;

        var iframe = document.createElement('iframe');
        iframe.setAttribute('border', '0');
        iframe.style.position = 'absolute';
        iframe.src = this.src;

        if (iframe.nodeName == 'iframe')
        {
            iframe.style.rotation = this.rotation;
        }
        else if (this.rotation != 0)
        {
            // LATER: Add flipV/H support
            mxUtils.setPrefixedStyle(iframe.style, 'transform', 'rotate(' + this.rotation + 'deg)');
        }
        else
        {
            mxUtils.setPrefixedStyle(iframe.style, 'transform', '');
        }

        // Known problem: IE clips top line of image for certain angles
        iframe.style.width = this.node.style.width;
        iframe.style.height = this.node.style.height;

        this.node.style.backgroundImage = '';

        console.log("iframe", iframe);
        this.node.appendChild(iframe);
    }
    else
    {
        this.setTransparentBackgroundImage(this.node);
    }
};
mxCellRenderer.registerShape('iframe', IframeShape);

//Card Shape
function CardShape()
{
    mxRectangleShape.call(this);
}
mxUtils.extend(CardShape, mxRectangleShape);

CardShape.prototype.paintBackground = function(c, x, y, w, h) {
    const stroke = this.stroke;
    this.stroke = '#e3e3e3';
    c.setStrokeColor('#e3e3e3');
    mxRectangleShape.prototype.paintBackground.call(this, c, x, y, w, h);
    this.stroke = stroke;
    c.setStrokeColor(this.stroke);
    c.begin();
    c.setStrokeWidth(10);
    c.setShadow(false);
    c.moveTo(x - 0.5, y + 4);
    c.lineTo(x + w + 0.5, y + 4);
    c.end();
    c.stroke();
}
CardShape.prototype.getLabelBounds = function(rect)
{
    var d = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
    var verticalAlign = mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_ALIGN, 'middle');
    var bounds = rect;
    if(verticalAlign === 'top') {
        bounds.y = rect.y + 10;
    }
    bounds.x = rect.x + 10;
    bounds.width = rect.width - 20;

    // Normalizes argument for getLabelMargins hook
    if (d != mxConstants.DIRECTION_SOUTH && d != mxConstants.DIRECTION_NORTH &&
        this.state != null && this.state.text != null &&
        this.state.text.isPaintBoundsInverted())
    {
        bounds = bounds.clone();
        var tmp = bounds.width;
        bounds.width = bounds.height;
        bounds.height = tmp;
    }

    var m = this.getLabelMargins(bounds);

    if (m != null)
    {
        var flipH = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, false) == '1';
        var flipV = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, false) == '1';

        // Handles special case for vertical labels
        if (this.state != null && this.state.text != null &&
            this.state.text.isPaintBoundsInverted())
        {
            var tmp = m.x;
            m.x = m.height;
            m.height = m.width;
            m.width = m.y;
            m.y = tmp;

            tmp = flipH;
            flipH = flipV;
            flipV = tmp;
        }

        return mxUtils.getDirectedBounds(rect, m, this.style, flipH, flipV);
    }

    return bounds;
};
mxCellRenderer.registerShape('card', CardShape);


/**
 * Registers shapes.
 */
(function()
{
	// Cube Shape, supports size style
	function CubeShape()
	{
		mxCylinder.call(this);
	};
	mxUtils.extend(CubeShape, mxCylinder);
	CubeShape.prototype.size = 20;
	CubeShape.prototype.redrawPath = function(path, x, y, w, h, isForeground)
	{
		var s = Math.max(0, Math.min(w, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'size', this.size)))));

		if (isForeground)
		{
			path.moveTo(s, h);
			path.lineTo(s, s);
			path.lineTo(0, 0);
			path.moveTo(s, s);
			path.lineTo(w, s);
			path.end();
		}
		else
		{
			path.moveTo(0, 0);
			path.lineTo(w - s, 0);
			path.lineTo(w, s);
			path.lineTo(w, h);
			path.lineTo(s, h);
			path.lineTo(0, h - s);
			path.lineTo(0, 0);
			path.close();
			path.end();
		}
	};
	CubeShape.prototype.getLabelMargins = function(rect)
	{
		if (mxUtils.getValue(this.style, 'boundedLbl', false))
		{
			var s = parseFloat(mxUtils.getValue(this.style, 'size', this.size)) * this.scale;

			return new mxRectangle(s, s, 0, 0);
		}

		return null;
	};

	mxCellRenderer.registerShape('cube', CubeShape);

    /**
     * Adds handJiggle style (jiggle=n sets jiggle)
     */
    function HandJiggle(canvas, defaultVariation)
    {
        this.canvas = canvas;

        // Avoids "spikes" in the output
        this.canvas.setLineJoin('round');
        this.canvas.setLineCap('round');

        this.defaultVariation = defaultVariation;

        this.originalLineTo = this.canvas.lineTo;
        this.canvas.lineTo = mxUtils.bind(this, HandJiggle.prototype.lineTo);

        this.originalMoveTo = this.canvas.moveTo;
        this.canvas.moveTo = mxUtils.bind(this, HandJiggle.prototype.moveTo);

        this.originalClose = this.canvas.close;
        this.canvas.close = mxUtils.bind(this, HandJiggle.prototype.close);

        this.originalQuadTo = this.canvas.quadTo;
        this.canvas.quadTo = mxUtils.bind(this, HandJiggle.prototype.quadTo);

        this.originalCurveTo = this.canvas.curveTo;
        this.canvas.curveTo = mxUtils.bind(this, HandJiggle.prototype.curveTo);

        this.originalArcTo = this.canvas.arcTo;
        this.canvas.arcTo = mxUtils.bind(this, HandJiggle.prototype.arcTo);
    };

    HandJiggle.prototype.moveTo = function(endX, endY)
    {
        this.originalMoveTo.apply(this.canvas, arguments);
        this.lastX = endX;
        this.lastY = endY;
        this.firstX = endX;
        this.firstY = endY;
    };

    HandJiggle.prototype.close = function()
    {
        if (this.firstX != null && this.firstY != null)
        {
            this.lineTo(this.firstX, this.firstY);
            this.originalClose.apply(this.canvas, arguments);
        }

        this.originalClose.apply(this.canvas, arguments);
    };

    HandJiggle.prototype.quadTo = function(x1, y1, x2, y2)
    {
        this.originalQuadTo.apply(this.canvas, arguments);
        this.lastX = x2;
        this.lastY = y2;
    };

    HandJiggle.prototype.curveTo = function(x1, y1, x2, y2, x3, y3)
    {
        this.originalCurveTo.apply(this.canvas, arguments);
        this.lastX = x3;
        this.lastY = y3;
    };

    HandJiggle.prototype.arcTo = function(rx, ry, angle, largeArcFlag, sweepFlag, x, y)
    {
        this.originalArcTo.apply(this.canvas, arguments);
        this.lastX = x;
        this.lastY = y;
    };

    HandJiggle.prototype.lineTo = function(endX, endY)
    {
        // LATER: Check why this.canvas.lastX cannot be used
        if (this.lastX != null && this.lastY != null)
        {
            var dx = Math.abs(endX - this.lastX);
            var dy = Math.abs(endY - this.lastY);
            var dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 2)
            {
                this.originalLineTo.apply(this.canvas, arguments);
                this.lastX = endX;
                this.lastY = endY;

                return;
            }

            var segs = Math.round(dist / 10);
            var variation = this.defaultVariation;

            if (segs < 5)
            {
                segs = 5;
                variation /= 3;
            }

            function sign(x)
            {
                return typeof x === 'number' ? x ? x < 0 ? -1 : 1 : x === x ? 0 : NaN : NaN;
            }

            var stepX = sign(endX - this.lastX) * dx / segs;
            var stepY = sign(endY - this.lastY) * dy / segs;

            var fx = dx / dist;
            var fy = dy / dist;

            for (var s = 0; s < segs; s++)
            {
                var x = stepX * s + this.lastX;
                var y = stepY * s + this.lastY;

                var offset = (Math.random() - 0.5) * variation;
                this.originalLineTo.call(this.canvas, x - offset * fy, y - offset * fx);
            }

            this.originalLineTo.call(this.canvas, endX, endY);
            this.lastX = endX;
            this.lastY = endY;
        }
        else
        {
            this.originalLineTo.apply(this.canvas, arguments);
            this.lastX = endX;
            this.lastY = endY;
        }
    };

    HandJiggle.prototype.destroy = function()
    {
        this.canvas.lineTo = this.originalLineTo;
        this.canvas.moveTo = this.originalMoveTo;
        this.canvas.close = this.originalClose;
        this.canvas.quadTo = this.originalQuadTo;
        this.canvas.curveTo = this.originalCurveTo;
        this.canvas.arcTo = this.originalArcTo;
    };

    // Installs hand jiggle in all shapes
    var mxShapePaint0 = mxShape.prototype.paint;
    mxShape.prototype.defaultJiggle = 1.5;
    mxShape.prototype.paint = function(c)
    {
        // NOTE: getValue does not return a boolean value so !('0') would return true here and below
        if (this.style != null && mxUtils.getValue(this.style, 'comic', '0') != '0' && c.handHiggle == null)
        {
            c.handJiggle = new HandJiggle(c, mxUtils.getValue(this.style, 'jiggle', this.defaultJiggle));
        }

        mxShapePaint0.apply(this, arguments);

        if (c.handJiggle != null)
        {
            c.handJiggle.destroy();
            delete c.handJiggle;
        }
    };

    // Sets default jiggle for diamond
    mxRhombus.prototype.defaultJiggle = 2;

    /**
     * Overrides to avoid call to rect
     */
    var mxRectangleShapeIsHtmlAllowed0 = mxRectangleShape.prototype.isHtmlAllowed;
    mxRectangleShape.prototype.isHtmlAllowed = function()
    {
        return (this.style == null || mxUtils.getValue(this.style, 'comic', '0') == '0') &&
            mxRectangleShapeIsHtmlAllowed0.apply(this, arguments);
    };

    var mxRectangleShapePaintBackground0 = mxRectangleShape.prototype.paintBackground;
    mxRectangleShape.prototype.paintBackground = function(c, x, y, w, h)
    {
        if (c.handJiggle == null)
        {
            mxRectangleShapePaintBackground0.apply(this, arguments);
        }
        else
        {
            var events = true;

            if (this.style != null)
            {
                events = mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1') == '1';
            }

            if (events || (this.fill != null && this.fill != mxConstants.NONE) ||
                (this.stroke != null && this.stroke != mxConstants.NONE))
            {
                if (!events && (this.fill == null || this.fill == mxConstants.NONE))
                {
                    c.pointerEvents = false;
                }

                c.begin();

                if (this.isRounded)
                {
                    var r = 0;

                    if (mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0) == '1')
                    {
                        r = Math.min(w / 2, Math.min(h / 2, mxUtils.getValue(this.style,
                            mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));
                    }
                    else
                    {
                        var f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE,
                            mxConstants.RECTANGLE_ROUNDING_FACTOR * 100) / 100;
                        r = Math.min(w * f, h * f);
                    }

                    c.moveTo(x + r, y);
                    c.lineTo(x + w - r, y);
                    c.quadTo(x + w, y, x + w, y + r);
                    c.lineTo(x + w, y + h - r);
                    c.quadTo(x + w, y + h, x + w - r, y + h);
                    c.lineTo(x + r, y + h);
                    c.quadTo(x, y + h, x, y + h - r);
                    c.lineTo(x, y + r);
                    c.quadTo(x, y, x + r, y);
                }
                else
                {

                    c.moveTo(x, y);
                    c.lineTo(x + w, y);
                    c.lineTo(x + w, y + h);
                    c.lineTo(x, y + h);
                    c.lineTo(x, y);
                }

                // LATER: Check if close is needed here
                c.close();
                c.end();

                c.fillAndStroke();
            }
        }
    };

    /**
     * Disables glass effect with hand jiggle.
     */
    var mxRectangleShapePaintForeground0 = mxRectangleShape.prototype.paintForeground;
    mxRectangleShape.prototype.paintForeground = function(c, x, y, w, h)
    {
        if (c.handJiggle == null)
        {
            mxRectangleShapePaintForeground0.apply(this, arguments);
        }
    };

    mxRectangleShape.prototype.getLabelBounds = function(rect)
    {
        var d = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
        var bounds = rect;
        if(this.state && this.state.cell && inspectioUtils.isTextField(this.state.cell) && bounds.width > 100) {
            bounds.x = rect.x + 30;
            bounds.width = rect.width - 60;
        }

        // Normalizes argument for getLabelMargins hook
        if (d != mxConstants.DIRECTION_SOUTH && d != mxConstants.DIRECTION_NORTH &&
            this.state != null && this.state.text != null &&
            this.state.text.isPaintBoundsInverted())
        {
            bounds = bounds.clone();
            var tmp = bounds.width;
            bounds.width = bounds.height;
            bounds.height = tmp;
        }

        var m = this.getLabelMargins(bounds);

        if (m != null)
        {
            var flipH = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, false) == '1';
            var flipV = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, false) == '1';

            // Handles special case for vertical labels
            if (this.state != null && this.state.text != null &&
                this.state.text.isPaintBoundsInverted())
            {
                var tmp = m.x;
                m.x = m.height;
                m.height = m.width;
                m.width = m.y;
                m.y = tmp;

                tmp = flipH;
                flipH = flipV;
                flipV = tmp;
            }

            return mxUtils.getDirectedBounds(rect, m, this.style, flipH, flipV);
        }

        return bounds;
    };

    // End of hand jiggle integration
})();
